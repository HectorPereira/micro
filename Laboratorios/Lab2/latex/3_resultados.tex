\section{Resultados}
% En esta secci√≥n se presentan los resultados obtenidos durante la implementaci√≥n y prueba de los distintos m√≥dulos desarrollados: el sistema de reconocimiento de colores, el piano electr√≥nico, la cerradura con contrase√±a y el control del plotter. Cada m√≥dulo fue verificado individualmente en simulaci√≥n y en montaje f√≠sico, registrando su funcionamiento y las principales observaciones.

\subsection{Resultados por m√≥dulo}

\subsubsection{Plotter}
% Explic√° c√≥mo se verific√≥ el movimiento (por ejemplo, ejecuci√≥n de trayectorias simples o figuras predefinidas).

% Mostr√° fotos o diagramas de movimiento, si ten√©s.

% Coment√° observaciones: velocidad, precisi√≥n, limitaciones por USART.

% üí¨ Ejemplo:

% El plotter ejecut√≥ correctamente trayectorias lineales y circulares generadas desde un script en Python. Se comprob√≥ que, al reducir la tasa de env√≠o por USART, la respuesta del sistema fue m√°s fluida y sin interrupciones perceptibles.

\subsubsection{Colores}
% Mostr√° la tabla o los valores obtenidos por el LDR para cada color calibrado.

% Inclu√≠ una figura de la tira LED mostrando el color detectado o el √°ngulo del servo.

% Mencion√° el comportamiento: estabilidad, sensibilidad a la luz ambiente, etc.

% üí¨ Ejemplo:

% El sistema logr√≥ identificar correctamente los colores b√°sicos (rojo, verde, azul, amarillo, violeta y blanco). Los valores de tensi√≥n medidos variaron entre 0,4 V y 3,2 V seg√∫n la intensidad reflejada. Se observ√≥ que la calibraci√≥n inicial mejora la repetibilidad, reduciendo errores al repetir la medici√≥n sobre el mismo color.

% ----------------------------------------- RAMBLINGS

% Reconocer colores
% Como se reconoce un color
% Un color se puede descomoner en otros colores
% Colores primarios
% Colores CYMK
% Colores RGB
% Un LDR no puede medir componentes
% Un LDR solo mide luz reflejada
% Si iluminamos con luz blanca el LDR mide la cantidad de luz blanca que rebota
% Seria como tener vision en blanco y negro
% Algunos colores serian dificiles de identificar

% Si iluminamos con otro color el LDR ve la cantidad de luz que refleja de ese color
% Si iluminamos con rojo, luego verde, y luego azul el LDR puede identificar 
% colores con 3 grados de libertad como el ojo humano.

% Se utiliza un led RGB para iluminar con estos colores

% El LDR no responde la misma manera a todos los tipos de luz. 
% Los valores medidos no se van a correlacionar de manera directa
% Con las componentes tradicionales de cada color.
% Ademas de que existen variaciones de emision de luz entre los mismos colores del led

% Sin embargo es suficiente si lo calibramos antes

% Utilizando un divisor de voltaje se conecta el ldr a un pin analogico del arduino

% Se ilumina con rojo verde y azul para cada color y se recopilan los valores medidos por el ADC

% Se mapean los 6 colores de la hoja para tomar como referencias.

% Para determinar el color el cual el LDR esta apuntando
% se calcula cual es el valor m√°s pr√≥ximo tomando
% en cuenta los 3 componentes como ejes de libertad
% realizando un calculo de distancia cartesiana.
% A2 + B2 + C2 = D2

% En este caso rojo verde y azul representan un eje en un espacio tridimensional. 
% Los colores calibrados representan vectores. Y el vector de medici√≥n se 
% mueve a lo largo de todo este espacio adquiriendo diferentes valores rgb.

% De manera ciclica se mide la distancia del vector medicion con respecto 
% al resto de vectores mapeados para identificar cual es el vector que 
% mas se aproxima al vector medici√≥n

% Problemas
% Como medir colores con presicion
% Como reconocer colores precalibrados
% Como controlar un servomotor
% Como controlar una tira LED

% Funcionaldiades
% Salida de info por USART
% Color indicado por angulo en servomotor
% Color indica

El proceso de reconocimiento de colores se fundamenta en la descomposici√≥n de cada color en sus componentes primarias dentro del modelo RGB (\textit{Red}, \textit{Green}, \textit{Blue}). Un color puede representarse como la combinaci√≥n ponderada de estas tres intensidades, lo que permite su descripci√≥n en un espacio tridimensional.  

\vspace{1em}

Sin embargo, el sensor fotoresistivo (LDR, \textit{Light Dependent Resistor}) utilizado en el sistema no distingue de forma individual las componentes crom√°ticas del espectro visible; √∫nicamente mide la intensidad total de luz reflejada sobre su superficie. Si la iluminaci√≥n se realiza con luz blanca, el sensor solo entrega una lectura proporcional a la cantidad total de luz reflejada, sin discriminar su composici√≥n espectral. Este fen√≥meno equivale a una percepci√≥n en escala de grises, dificultando la identificaci√≥n precisa de colores.

\vspace{1em}

Para resolver esta limitaci√≥n, se emple√≥ un diodo emisor de luz RGB como fuente de iluminaci√≥n controlada. Al iluminar secuencialmente la superficie con luz roja, verde y azul, el sistema obtiene tres mediciones independientes mediante el LDR. Dichos valores, convertidos por el m√≥dulo ADC (\textit{Analog-to-Digital Converter}) del microcontrolador ATmega328P, representan las coordenadas $(R, G, B)$ de un punto dentro de un espacio de color tridimensional.

\vspace{1em}

Dado que tanto la respuesta espectral del LDR como la emisi√≥n de los LED presentan variaciones no lineales, los valores obtenidos no son directamente proporcionales a las componentes RGB te√≥ricas. No obstante, el sistema logra resultados estables mediante un proceso de calibraci√≥n inicial, donde se iluminan sucesivamente los colores de referencia (rojo, verde, azul claro, violeta, morado, amarillo y blanco) y se almacenan sus valores de conversi√≥n anal√≥gica-digital.

\vspace{1em}

Cada color de referencia calibrado se modela como un vector fijo en dicho espacio. Para identificar un color, se calcula la distancia euclidiana entre el vector de medici√≥n y cada uno de los vectores de referencia almacenados:

\begin{equation}\label{eq:distancia_color}
D = \sqrt{(R_m - R_i)^2 + (G_m - G_i)^2 + (B_m - B_i)^2}
\end{equation}

donde $(R_m, G_m, B_m)$ representan los valores medidos por el sensor y $(R_i, G_i, B_i)$ corresponden a los valores calibrados de cada color de la hoja de referencia. El color identificado ser√° aquel cuya distancia $D$ sea m√≠nima.



\vspace{1em}

El circuito se implement√≥ mediante un divisor resistivo conectado a una de las entradas anal√≥gicas del microcontrolador. El color identificado se replica visualmente en la tira de LED WS2812, y el servomotor se posiciona en el √°ngulo correspondiente al color detectado dentro de la hoja de referencia, integrando as√≠ un sistema de selecci√≥n e identificaci√≥n de color completamente automatizado.












\subsubsection{Piano}

% Mostr√° capturas de los men√∫s USART, las canciones reproducidas o las frecuencias generadas.

% Explic√° el uso de interrupciones para reproducir melod√≠as sin detener el programa.

% Coment√° si el sonido fue limpio, si hubo desfase, o c√≥mo responden los botones.

% üí¨ Ejemplo:

% El piano electr√≥nico logr√≥ reproducir correctamente las melod√≠as ‚ÄúCha-La Head-Cha-La‚Äù y ‚ÄúStill Alive‚Äù. Cada nota se gener√≥ a partir del temporizador 0 configurado en modo CTC. La reproducci√≥n simult√°nea de pistas A y B mostr√≥ un leve desfase tras varios segundos de ejecuci√≥n, atribuible a peque√±as diferencias en el conteo de interrupciones.

% ---------------------------- RAMBLINGS

% Sonido
% Que es el sonido
% Ondas
% Difrentes tipos de ondas
% Como hacemos sonido
% Buzzer
% Onda cuadrada
% Como funciona el buzzer
% Piezo
% Como lo hacemos sonar con el atmega
% Variacion de frecuencia
% Como hacemos otro sonido
% Cambiamos la frencuencia
% Como hacemos musica
% Teoria musical basica
% Mapeo de notas
% Una nota es una frecuencia
% Una frecuencia durante un tiempo es una nota
% Como guardamos musica
% Nota musical: frencuencia, tiempo encendido, tiempo apagado
% Secuencia de notas musicales --- musica
% La musica se compone de varios instrumentos en paralelo
% Como reproducimos varios instrumentos
% Evitar polling --- Utilizar timers

% Problemas
% Como reproducir sonido
% Como representar una nota musical
% Como reproducir pistas en paralelo

% Funcionalidades
% Control por USART
% Piano fisico


El sonido es una onda mec√°nica que se propaga a trav√©s de un medio el√°stico, producto de variaciones peri√≥dicas de presi√≥n. Estas ondas pueden clasificarse seg√∫n su forma en senoidales, cuadradas, triangulares o diente de sierra, dependiendo del patr√≥n temporal de oscilaci√≥n. En los sistemas digitales, las se√±ales m√°s sencillas de generar son las ondas cuadradas, donde el voltaje alterna entre dos niveles definidos, representando los estados l√≥gicos alto y bajo del microcontrolador.

\vspace{1em}

Para producir sonido de manera electr√≥nica, se emplean dispositivos piezoel√©ctricos denominados \textit{buzzers}. Estos transductores convierten la energ√≠a el√©ctrica en vibraciones mec√°nicas audibles. Cuando el microcontrolador aplica una se√±al cuadrada a la entrada del buzzer, el material piezoel√©ctrico se deforma y contrae peri√≥dicamente, generando un sonido cuya frecuencia est√° directamente relacionada con la frecuencia de la se√±al de entrada.

\vspace{1em}

En el microcontrolador ATmega328P, esta se√±al se genera mediante el uso de los temporizadores internos (\textit{timers}), configurados para producir una onda cuadrada en un pin de salida. Al modificar la frecuencia de conmutaci√≥n, es posible variar el tono percibido, ya que la frecuencia del sonido determina su altura musical. De esta manera, cada nota puede asociarse a una frecuencia espec√≠fica seg√∫n la escala temperada. Por ejemplo, la nota \textit{La4} corresponde a una frecuencia de 440\,Hz, mientras que \textit{Do4} equivale aproximadamente a 262\,Hz.

\vspace{1em}

Una nota musical puede representarse computacionalmente mediante dos par√°metros fundamentales: la frecuencia de oscilaci√≥n, la duraci√≥n temporal durante la cual se mantiene activa y la duraci√≥n inactiva o en silencio. Cuando el buzzer emite una secuencia ordenada de notas, cada una con su tiempo de activaci√≥n y silencio, se obtiene una melod√≠a. En t√©rminos program√°ticos, una melod√≠a se define como un conjunto de estructuras de datos que contienen pares \texttt{(frecuencia, tiempo\_on, tiempo\_off)}, los cuales son procesados secuencialmente para generar la m√∫sica deseada.

\vspace{1em}

La reproducci√≥n simult√°nea de varios instrumentos en un entorno digital requiere el manejo de m√∫ltiples secuencias de notas en paralelo. Para lograrlo sin recurrir al uso de ciclos de espera activos (\textit{polling}), se utilizan interrupciones asociadas a los temporizadores. De este modo, el microcontrolador puede controlar la duraci√≥n y el inicio de cada nota de forma independiente y precisa, optimizando el uso del procesador y permitiendo la ejecuci√≥n de tareas concurrentes, como la lectura de entradas o la comunicaci√≥n serial, mientras la m√∫sica contin√∫a sonando de manera aut√≥noma.

\vspace{1em}

En s√≠ntesis, el sistema desarrollado utiliza un buzzer piezoel√©ctrico controlado por los temporizadores del ATmega328P para reproducir notas musicales definidas por su frecuencia y duraci√≥n. A trav√©s de la programaci√≥n de secuencias almacenadas en memoria, es posible interpretar melod√≠as completas y gestionar la reproducci√≥n de distintas canciones sin intervenci√≥n del usuario durante la ejecuci√≥n.






\subsubsection{Cerradura}

% Mostr√° el flujo de la interfaz (mensajes en LCD, ingreso de contrase√±a, cambio de clave, activaci√≥n de alarma).

% Si pod√©s, mostr√°s una tabla con los estados de la m√°quina y qu√© hace cada uno.

% Coment√° observaciones de funcionamiento en simulaci√≥n vs f√≠sico.

% üí¨ Ejemplo:

% El sistema respondi√≥ correctamente al ingreso de contrase√±as v√°lidas e inv√°lidas. Tras tres intentos fallidos, se activ√≥ la alarma visual y sonora. El cambio de contrase√±a fue exitoso y persisti√≥ tras apagar el microcontrolador, confirmando la correcta escritura en EEPROM. En PicSimLab, el teclado dej√≥ de responder tras reiniciar, pero en el hardware f√≠sico el funcionamiento fue estable.

% -------------------------- RAMBLINGS

% Cerradura
% Que tiene que hacer
% Candado cerrado
% Contrase√±a correcta
% Candado abierto
% Sino 3 veces alarma

% Cambiar contrase√±a
% Contra actual
% Contra nueva
% Guaradado

% Contrase√±as tienen que ser entre 4 y 6 digitos

% Problema
% Una interfaz de usuario
% Que es una interfaz
% Entradas y salidas
% El usuario hace algo y la interfaz muestra algo
% Es la parte del programa o sistema que se encarga
% de hablar con el usuario.
% Diferentes acciones muestran o hacen diferentes cosas
% Maquina de estados --- Transiciones de estado.
% Problema: Reproducir sonidos, hacer debouncing, manejar alarmas, pantalla LCD. 
% No existen suficientes timers
% Solucion: tareas o tasks
% Utilizar un contador de tiempo interno de 32 bits
% junto con un solo timer para manejar tareas en paralelo

% La tarea se ejecuta rapidamente en el main y compara el timepo que paso con 
% el tiempo especificado para una acci√≥n especifica.

% Un solo timer. Muchos delays sin polling.

% Otro problema
% Contrase√±a debe ser guardada aunque el sistema est√© apagado
% Solucion EEPROM
% Funcionamiento de la eeprom
% limitaciones de escritura de EEPROM
% Como leer
% Como escribir

% Otro problema
% Teclado matricial
% Usa menos pines, uno por fila uno por columna
% Como identificar botones presionados
% Respuesta multiplexado
% Filas funcionan como salidas
% Columnas funcionan como entradas (pullup interno)
% Al solamente apagar una fila a la vez (0) 
% va a hacer que el pin de esa columna se vuelva 0
% Funcion retorna el caracter que representa esa fila y columna
% Listo.


El sistema de cerradura electr√≥nica desarrollado tiene como objetivo controlar el acceso mediante una contrase√±a num√©rica almacenada en memoria no vol√°til. Inicialmente, el dispositivo se encuentra en estado de \textit{candado cerrado}. Cuando el usuario ingresa la contrase√±a correcta, el sistema cambia al estado de \textit{candado abierto}, permitiendo el acceso. En caso de introducir una contrase√±a incorrecta tres veces consecutivas, se activa una alarma ac√∫stica a trav√©s de un buzzer, indicando un intento de acceso no autorizado.

El sistema tambi√©n permite modificar la contrase√±a almacenada. Para ello, el usuario debe ingresar primero la contrase√±a actual y, tras su validaci√≥n, definir una nueva contrase√±a de entre cuatro y seis d√≠gitos. Esta nueva clave se almacena permanentemente en la memoria EEPROM del microcontrolador, garantizando su persistencia incluso despu√©s de un apagado o reinicio del sistema.

\vspace{1em}

\paragraph*{Interfaz de usuario e interacci√≥n}

La cerradura dispone de una interfaz de usuario compuesta por una pantalla LCD de 16x2, un teclado matricial 4x4 y tres indicadores luminosos (LED verde, LED rojo y alarma sonora). En este contexto, la interfaz constituye el medio de comunicaci√≥n entre el usuario y el sistema, mostrando mensajes informativos y recibiendo acciones por medio del teclado. Cada interacci√≥n del usuario genera una respuesta visual o ac√∫stica distinta, representando as√≠ un flujo de di√°logo entre ambos.

El sistema se dise√±√≥ siguiendo una l√≥gica de \textit{m√°quina de estados finitos}, en la que cada modo de operaci√≥n (men√∫ principal, ingreso de contrase√±a, cambio de clave, acceso autorizado, alarma, etc.) representa un estado. Las transiciones entre estados se producen en funci√≥n de las acciones del usuario y las condiciones del sistema. Este enfoque facilita la gesti√≥n de comportamientos complejos, simplifica el control del flujo de ejecuci√≥n y mejora la legibilidad del c√≥digo.

\vspace{1em}

\paragraph*{Teclado matricial y detecci√≥n de teclas}

El ingreso de datos se realiza mediante un teclado matricial 4x4 que combina filas y columnas, optimizando el uso de pines del microcontrolador. Las filas se configuran como salidas y las columnas como entradas con resistencias de \textit{pull-up} activadas. El proceso de lectura consiste en activar una fila a nivel bajo (0) mientras las dem√°s permanecen en alto (1); si alguna tecla de esa fila se encuentra presionada, la columna correspondiente cambia a nivel bajo, permitiendo identificar la intersecci√≥n entre fila y columna.  

Cada tecla se asocia a un car√°cter seg√∫n su posici√≥n dentro de la matriz, lo que permite retornar el valor num√©rico o simb√≥lico correspondiente. Para evitar falsas detecciones debido al rebote mec√°nico de los contactos, se aplica una rutina de \textit{debouncing} por software basada en peque√±os retardos temporizados.

\vspace{1em}

\paragraph*{Gesti√≥n temporal y concurrencia de tareas}

Durante el funcionamiento, el sistema debe ejecutar m√∫ltiples tareas de forma paralela: reproducci√≥n de sonidos, manejo de alarmas, parpadeo de LEDs, lectura del teclado y actualizaci√≥n de la pantalla LCD. Sin embargo, el ATmega328P dispone de un n√∫mero limitado de temporizadores, por lo que no es posible asignar un temporizador independiente a cada tarea.

Para resolver esta limitaci√≥n, se implement√≥ un esquema de ejecuci√≥n basado en un \textit{planificador de tareas} o \textit{task scheduler} de prop√≥sito general. Se utiliza un solo temporizador configurado para generar interrupciones peri√≥dicas, incrementando un contador global de 32 bits que act√∫a como referencia temporal (en milisegundos). Cada tarea compara el tiempo actual con el instante programado de su pr√≥xima ejecuci√≥n, y si se cumple el intervalo, se ejecuta la acci√≥n correspondiente. De este modo, m√∫ltiples eventos temporizados pueden coexistir sin emplear retardos bloqueantes ni t√©cnicas de \textit{polling}.

\vspace{1em}

\paragraph*{Almacenamiento persistente de la contrase√±a}

Para asegurar que la contrase√±a permanezca almacenada tras un apagado, se utiliza la memoria EEPROM interna del ATmega328P. Esta memoria no vol√°til permite conservar los datos durante d√©cadas sin alimentaci√≥n el√©ctrica, aunque posee un n√∫mero limitado de ciclos de escritura (aproximadamente $10^5$ operaciones por celda). Por ello, el sistema √∫nicamente escribe en EEPROM cuando el usuario confirma un cambio de contrase√±a, minimizando el desgaste de la memoria.

La lectura y escritura se realizan mediante las funciones de la biblioteca est√°ndar \texttt{avr/eeprom.h}, que permiten transferir cadenas de caracteres directamente desde y hacia direcciones espec√≠ficas de la EEPROM. As√≠, el sistema recupera la contrase√±a almacenada al inicio del programa y la compara con la ingresada por el usuario durante la operaci√≥n normal.

\vspace{1em}

\paragraph*{Resumen de funcionamiento}

En conjunto, la cerradura electr√≥nica combina la interacci√≥n mediante teclado y pantalla LCD, la gesti√≥n de tareas en tiempo real y el almacenamiento persistente de datos, logrando un sistema confiable y aut√≥nomo. El uso de una m√°quina de estados y un planificador temporal basado en un √∫nico temporizador permite controlar de manera eficiente m√∫ltiples procesos simult√°neos sin bloquear la ejecuci√≥n principal del programa.








\subsection{Evidencias gr√°ficas y mediciones}
% Capturas del LCD, fotos del montaje, gr√°ficos de lectura ADC, diagramas de flujo, etc.

% Si mediste tiempos, tensiones o corrientes, ponelos en tabla o gr√°fico simple.

\subsection{Comentario general}
% Un breve cierre que enlace con la secci√≥n de conclusiones:

	% En general, todos los m√≥dulos cumplieron los objetivos planteados. Se lograron lecturas estables, respuestas correctas y sincronizaci√≥n entre las distintas tareas, demostrando la integraci√≥n de hardware y software en un entorno embebido con recursos limitados.
